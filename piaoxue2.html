<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>题库</title>
    <meta name="viewport"
          content="width=device-width,hight=device-hight,minimum-scale=1.0,maximum-scale=1.0,ser-scalable=none">
    <script type="text/javascript" src="jquery.min.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 400%;
            margin: 0;
            padding: 0;
        }

        .container {
            width: 100%;
            height: 96%;
            margin: 0;
            padding: 0;
        }

        #text {
            width: 95%;
            background: transparent;
            border: 1px red dashed;
            display: flex;
            color: aliceblue;
            position: relative;
            bottom: 100%;
            line-height: 30px;
            margin-left: 50px;
            font-family: 等线;
            list-style-type: none;
        }

        ul {
            list-style-type: none;
        }

        ul li {
            margin-left: 50px;
        }
    </style>
</head>
<body>
<div id="jsi-snow-container" class="container"></div>
<div id="text">
    <div>
        <h1>java基础</h1>
        <!--JDK8新特性-->
        <ul>
            一、JDK8新特性<br>
            <li>
                1、接口的默认方法：Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法<br>
                2、Lambda 表达式：每一个lambda表达式都对应一个类型，通常是接口类型<br>
                3、函数式接口：而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。<br>
                4、方法与构造函数引用：Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用<br>
                5、Lambda 作用域：在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。<br>
                6、访问局部变量：我们可以直接在lambda表达式中访问外层的局部变量<br>
                7、访问对象字段与静态变量：和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的。<br>
                8、访问接口的默认方法：Lambda表达式中是无法访问到默认方法的<br>
                9、Annotation 注解：在Java 8中支持多重注解了，Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可<br>
                注：JDK 1.8
                API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。
                Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的。<br>
                Optional 接口：Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念。Optional
                被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java
                8中，不推荐你返回null而是返回Optional。<br>
                Stream 接口：java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream
                操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如
                java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。Java 8扩展了集合类，可以通过 Collection.stream() 或者
                Collection.parallelStream() 来创建一个Stream。<br>
                Filter过滤：过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。
                forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。
                <br>
            </li>
        </ul>
        <!--面向对象-->
        <ul>
            二、面向对象
            <li>
                1、面向对象三大主要特征：封装、继承、多态<br>
                &ensp; &ensp; &nabla; 封装：
                属性私有化 Private
                公开的访问方法，set赋值（有参数 无返回值）,get取值（无参数 有返回值）
                添加有参数和无参数的构造方法<br>
                &ensp; &ensp; &nabla;
                this和super关键字：this关键字是为了解决实例变量和局部变量之间发生的同名冲突this关键字代表当前对象super指向超类对象的一个指针，而这个超类指的是离自己最近的一个父类
                <br>
                2、继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或者子类从父类继承方法，使得子类具有父类相同的行为。<br>
                &ensp; &ensp; &nabla; 继承的特性：子类拥有父类非private的属性、方法；子类有自己的方法、属性，也可以对父类进行扩展。<br>
                3、多态：是同一个行为具有多个不同表现形式或形态能力.<br>
                &ensp; &ensp; &nabla; 总结：编译，看左边；运行，看右边。属性看左边，方法看右边。<br>
                &ensp; &ensp; &nabla; 多态存在的三个必要条件：继承、重写、父类引用指向子类。<br>
                4、抽象类和接口的区别<br>
                &ensp; &ensp; &nabla; 抽象类使用abstract修饰 ，接口使用interface修饰。<br>
                &ensp; &ensp; &nabla; 抽象类可以有普通方法，有抽象方法的一定要有抽象类，接口不可有有普通方法只能有抽象类。<br>
                &ensp; &ensp; &nabla; 抽象类可有有普通属性，接口只能是常量。<br>
                &ensp; &ensp; &nabla; 抽象类和接口不能实例化，就是不能new，就是不能创建对象，因为不是具体的。<br>
                &ensp; &ensp; &nabla; 抽象类有构造方法，接口没有构造方法。<br>
                &ensp; &ensp; &nabla; 抽象类只支持单继承支持多实现，接口支持多继承。<br>
                5、重写和重载的区别<br>
                &ensp; &ensp; &nabla; 重载发生在同一类中，重写发生在父子类继承关系中<br>
                &ensp; &ensp; &nabla; 重写要求重写非私有非静态的方法，重载没有要求。<br>
                &ensp; &ensp; &nabla; 重载与返回值无关，重写要求返回值必须一致<br>
                &ensp; &ensp; &nabla; 重载要求参数类型顺序个数只要有一个不同，重写要求参数必须相同<br>
                &ensp; &ensp; &nabla; 重写要求子类的访问权限不得小于父类 但是重载没有求<br>
                &ensp; &ensp; &nabla; 重写要求子类不得抛出比父类更多更大的异常，重载没有要求<br>
                6、Java 异常处理的五个关键字是什么？<br>
                &ensp; &ensp; &nabla; try catch finally throw throws<br>
                7、error 和 exception 有什么区别？<br>
                &ensp; &ensp; &nabla; error:提示错误信息；exception:异常类提示<br>
                8、final、finally、finalize 的区别？<br>
                &ensp; &ensp; &nabla; final：修饰类，最终类不能被继承;修饰方法 不能被重写，但可以被重载;修饰变量变常量，得赋值<br>
                &ensp; &ensp; &nabla; finally：用在try catch 的后面，不管程序是否执行成功，都会执行finally<br>
                &ensp; &ensp;
                &nabla;finalize：inalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用<br>
                7、什么是String，它是什么数据类型？<br>
                &ensp; &ensp; &nabla; String是定义在 java.lang 包下的一个类。它不是基本数据类型。<br>
                &ensp; &ensp; &nabla; String是不可变的，JVM使用字符串池来存储所有的字符串对象。<br>
                String是不可变的有什么好处？<br>
                &ensp; &ensp; &nabla; 由于String是不可变类，所以在多线程中使用是安全的，我们不需要做任何其他同步操作。<br>
                &ensp; &ensp; &nabla; String是不可变的，它的值也不能被改变，所以用来存储数据密码很安全。<br>
                9、装箱：就是自动将基本数据类型转换为包装器类型 int包装成Integer float包装成Float<br>
                10、拆箱：就是自动将包装器类型转换为基本数据类型 int b=new Integer(10) //这是自动拆箱<br>
                注意：当定义的Integer的值大于-128-127之间不计较两个值是否相等时true如果不在这个范围内的false<br>
                11、String s = new String("abc") 创建了几个对象？<br>
                &ensp; &ensp; &nabla; 2个对象 一个在堆内存中，一个在常量池中<br>
                &ensp; &ensp; &nabla; String有什么特点<br>
                &ensp; &ensp; &nabla; String不可变，在使用String的时候尽量不使用+拼接<br>
                &ensp; &ensp; &nabla; String类是被final修饰的所以不能被继承<br>
                11、String、StringBuffer和StringBuilder都有什么区别？<br>
                &ensp; &ensp; &nabla; String是不可变的，连接效率低<br>
                &ensp; &ensp; &nabla; StringBuffer是可变的字符串类型，连接效率高于String线程安全<br>
                &ensp; &ensp; &nabla; StringBuilder是可变的字符类型，连接效率高于StringBuffer，线程不安全<br>
                &ensp; &ensp; &nabla; 了解：线程安全和线程不安全要放在多线程安全下说<br>
                &ensp; &ensp; &nabla; 问题：默认情况下扩容为原来容量的2倍+2，同时原有的数组中的元素赋值到新的数组<br>
            </li>
        </ul>
        <!--集合-->
        <ul>
            三、集合<br>
            <li>
                1、ArrayList,LinkedList,Vector三者的相同点与不同点<br>
                &ensp; &ensp; &nabla; 三个类都是实现了List接口，存储数据的特点相同，存储有序的，可重复的数据。<br>
                &ensp; &ensp; &nabla; ArrayList：<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ①作为List接口的主要实现类；<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ②线程不安全的，效率高；<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ③底层使用Object[] 存储。<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ④JDK7/8：创建集合底层数组初始化一个空数组，第一次调用add方法才创建长度为10的数组<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ⑤JDK6：创建集合默认长度为10<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ⑥在扩容方面是超过之前的长度，则扩展之前的长度为原来的1.5倍<br>
                &ensp; &ensp; &nabla; LinkedList：<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ① 对于频繁的插入，删除操作，使用此类效率比ArraysList高；<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ② 线程不安全，底层使用双向链表存储<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ③ 内部声明了Node类型的first和last属性，默认值为null<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ④ 调用add()方法将数据封装到Node中，创建了Node对象<br>
                &ensp; &ensp; &nabla; Vector：<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ①线程安全，效率低<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ②jdk7和jdk8中通过Vector构造器创建对象时，底层创建了长度为10的数组<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ③在扩容方面，默认扩容为原来的数组长度的2倍<br>
                2、说说常见的集合有哪些吧？<br>
                &ensp; &ensp; &nabla; Map接口和Collection接口是所有集合框架的父接口。<br>
                &ensp; &ensp; &nabla; Collection接口的子接口包括：Set接口和List接口<br>
                &ensp; &ensp; &nabla; Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等<br>
                &ensp; &ensp; &nabla; Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等<br>
                &ensp; &ensp; &nabla; List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等<br>
                3、HashMap与HashTable的区别？<br>
                &ensp; &ensp; &nabla; HashMap没有考虑同步，是线程不安全的。Hashtable使用了synchronized关键字，是线程安全的。<br>
                &ensp; &ensp; &nabla; HashMap允许K/V都为null。后者K/V都不允许为null。<br>
                &ensp; &ensp; &nabla; HashMap继承自AbstractMap类。而Hashtable继承自Dictionary类。<br>
                4、什么是哈希冲突？<br>
                &ensp; &ensp; &nabla; 当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞(哈希碰撞)。<br>
                5、HashSet是如何保证数据不可重复的？<br>
                &ensp; &ensp; &nabla; HashSet的底层其实就是HashMap，由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，
                然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性<br>
                6、List、Map、Set三个接口，存取元素时，各有什么特点<br>
                &ensp; &ensp; &nabla; List 以特定次序来持有元素，可有重复元素；<br>
                &ensp; &ensp; &nabla; Set 无法拥有重复元素,内部排序（无序）；<br>
                &ensp; &ensp; &nabla; Map 保存key-value值，value可多值。<br>
                7、请问HashMap和HashSet的区别是什么呢？<br>
                &ensp; &ensp; &nabla; hashmap是使用的是唯一键获取对象的，hashmap相对于hashset比较快一些；hashmap存储是键值对，而ahshset存储是对象。<br>
                8、Set存储数据的特点是什么？常见的实现类有什么？说明一下彼此的特点。<br>
                &ensp; &ensp; &nabla; Set接口常用的方法：和Collection一样<br>
                &ensp; &ensp; &nabla; 存储特点：相对无序存储，不可以存储相同的元素(排重)，不能通过下标访问<br>
                &ensp; &ensp; &nabla; HashSet：------- hashSet实现了HashMap键的维护<br>
                &ensp; &ensp; &nabla; 特点：无序，不可重复<br>
                &ensp; &ensp; &nabla; 相对无序存储，不可以存储相同元素（排重），通过哈希表实现的集合<br>
                &ensp; &ensp; &nabla; hashCode是Object中的方法，每个对象的hashCode值是唯一的，所以可以理解成hashCode值表示这个对象在内存中的位置<br>
                &ensp; &ensp; &nabla; equlas()方法是Object中的方法，表示比较两个对象是否相等，若不重写相当于比较对象的地址值<br>
                &ensp; &ensp; &nabla; LinkedHashSet：<br>
                &ensp; &ensp; &nabla; LinkedHashSet类是具有可预知迭代顺序(相对有序)的Set接口的哈希表和链接列表实现。是HashSet的子类<br>
                &ensp; &ensp; &nabla; 存储特点：相对有序的存储，不可以存储相同的元素(排重)，通过链表实现的集合(注定相对有序)<br>
                &ensp; &ensp; &nabla; LinkedHashSet集合的元素排重与HashSet集合拍重方法一致<br>
                &ensp; &ensp; &nabla; TreeSet：------（排序）集合:TreeSet是TreeMap的键的维护<br>
                &ensp; &ensp; &nabla; 底层使用treeMap实现，实现了sortedset接口。红黑树实现，不允许重复。可以自然和定制排序<br>
            </li>
        </ul>
        <!--多线程-->
        <ul>
            四、多线程<br>
            2、实现一个线程有哪几种方式,各有什么优缺点,比较常用的是那种,为什么?<br>
            &ensp; &ensp; &nabla; 继承Thread类,需要重写run方法,无返回值<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; ① 优点:可以直接调用start方法启动线程<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; ② 缺点:java只能单继承,如果已经有了父类,不能用这种方法<br>
            &ensp; &ensp; &nabla; 实现Runnable接口,需要重写run()方法<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; ① 优点:即使自己定义的线程类有了父类也可以实现接口,而且接口是多实现<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; ② 缺点:需通过构造一个Thread把自己传进去,才能实现Thread的方法,代码复杂<br>
            &ensp; &ensp; &nabla; 实现Callable接口,需要重写call()方法<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; ① 优点:可以抛出异常,有返回值<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; ② 缺点:只有jdk1.5以后才支持,结合FuntureTask和Thread类一起使用,最后调用start启动线程<br>
            3、wait和sleep有什么区别和联系,他们执行的时候是否都会释放锁<br>
            &ensp; &ensp; &nabla; Wait和sleep都可以使线程暂停,但wait必须在synchronized修饰的方法或代码块中使用。<br>
            &ensp; &ensp; &nabla;
            Sleep()方法是线程类的静态方法,调用此方法会让当前线程暂停执行指定的时间,将执行机会(CPU)让给其它线程,但是对象的锁依然保持,因此休眠时间结束后会自动恢复(就绪状态)。<br>
            &ensp; &ensp; &nabla; wait()是Object类的方法,调用对象的wait()方法会让当前线程放弃对象的锁(线程暂停执行),进入对象的等待池(wait
            pool),只有调用对象的Notify()或notifyAll()方法才能唤醒等待池中的线程进入等锁池(lock pool),如果线程重新获得对象的锁就可以进入就绪状态。<br>
            4、线程的生命周期<br>
            &ensp; &ensp; &nabla; 生命周期<br>
            &ensp; &ensp; &nabla; 新建<br>
            &ensp; &ensp; &nabla; 就绪<br>
            &ensp; &ensp; &nabla; 运行<br>
            &ensp; &ensp; &nabla; 堵塞<br>
            &ensp; &ensp; &nabla; 死亡<br>
            5、单例模式
            &ensp; &ensp; &nabla; 顾名思义就是只有一个实例，并且她自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>
            &ensp; &ensp; &ensp; &ensp; &nabla; public class LHan{<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private static LHan instance;<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private LHan(){};<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private static LHan getInstance(){<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;if(instance==null){<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;&ensp; &ensp;instance = new LHan();<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;}<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;return instance;<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; }<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; }<br>
            &ensp; &ensp; &nabla;
            懒汉式，顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。有线程安全和线程不安全两种写法，区别就是synchronized关键字。<br>
            &ensp; &ensp; &ensp; &ensp; &nabla; public class EHan{<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private static EHan instance = new EHan();<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private EHan(){};<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private static EHan getInstance(){<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp;return instance;<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; }<br>
            &ensp; &ensp; &nabla; 饿汉式，从名字上也很好理解，就是“比较勤”，实例在初始化的时候就已经建好了，不管你有没有用到，都先建好了再说。好处是没有线程安全的问题，坏处是浪费内存空间。<br>
            &ensp; &ensp; &ensp; &ensp; &nabla; public class DoubleCheck{<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private static DoubleCheck instance;<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private DoubleCheck(){};<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; private static DoubleCheck getInstance(){<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;if(instance==null){<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;&ensp; synchronized(DoubleCheck.class){<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;&ensp; &ensp;if(instance==null){<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;&ensp; &ensp;instance = new DoubleCheck();<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;&ensp; &ensp;}<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;&ensp;}<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp;&ensp; &ensp;return instance;<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; &ensp; }<br>
            &ensp; &ensp; &ensp; &ensp; &ensp; }<br>
            &ensp; &ensp; &nabla; 双检锁，又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。看上面代码实现中，特点是在synchronized关键字内外都加了一层 if
            条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。<br>
        </ul>
        <!--Web框架-->
        <ul>
            四、Web框架<br>
            <li>
                1、angular内置过滤器一共有几种，分别是那些？<br>
                &ensp; &ensp; &nabla; date：日期格式化<br>
                &ensp; &ensp; &nabla; currency：货币<br>
                &ensp; &ensp; &nabla; uppercase：大写<br>
                &ensp; &ensp; &nabla; lowercase：小写<br>
                &ensp; &ensp; &nabla; limitTo（限制数组或字符串长度）<br>
                &ensp; &ensp; &nabla; orderBy（排序）<br>
                &ensp; &ensp; &nabla; number（格式化数字，加上千位分隔符，并接收参数限定小数点位数）<br>
                &ensp; &ensp; &nabla; filter（处理一个数组，过滤出含有某个子串的元素）<br>
                &ensp; &ensp; &nabla; json（格式化 json 对象）<br>
                2、angular 核心？<br>
                &ensp; &ensp; &nabla; AngularJS是为了克服HTML在构建应用上的不足而设计的。 AngularJS有着诸多特性，最为核心的是：<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ①MVC<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ②模块化<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ③自动化双向数据绑定<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ④语义化标签、依赖注入等等<br>
                3、angular的数据绑定采用什么机制？详述原理？<br>
                &ensp; &ensp; &nabla; angularjs的双向数据绑定采用脏检查（dirty-checking）机制。ng只有在指定事件触发后，才进入 $digest cycle ：<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ①DOM事件，譬如用户输入文本，点击按钮等。( ng-click )<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ②XHR响应事件 ( $http )<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ③浏览器Location变更事件 ( $location )<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ④Timer事件( $timeout , $interval )<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ⑤执行 $digest() 或 $apply()<br>
                4、依赖注入(DI)<br>
                &ensp; &ensp; &nabla; 让我们可以不用自己实例化就能创建依赖对象的方法. 简单的来说, 依赖是以注入的方式传递的. 在Web应用中，
                Angular让我们可以通过DI来创建像Controllers和Directives这样的对象. 我们还可以创建自己的依赖对象, 当我们要实例化它们时, Angular能自动实现注入.<br>
                5、解释下什么是$rootScrope以及和$scope的区别？<br>
                &ensp; &ensp; &nabla; 通俗的说$rootScrope 页面所有$scope的父亲。<br>
                &ensp; &ensp; &nabla; Angular解析ng-app然后在内存中创建$rootScope。<br>
                &ensp; &ensp; &nabla; angular回继续解析，找到{{}}表达式，并解析成变量。<br>
                &ensp; &ensp; &nabla; 接着会解析带有ng-controller的div然后指向到某个controller函数。这个时候在这个controller函数变成一个$scope对象实例。<br>
                6、factory 和 service，provider是什么关系？<br>
                &ensp; &ensp; &nabla; factory 把 service 的方法和数据放在一个对象里，并返回这个对象；service 通过构造函数方式创建
                service，返回一个实例化对象；provider 创建一个可通过 config
                配置的 service。<br>
                &ensp; &ensp; &nabla; 从底层实现上来看，service 调用了 factory，返回其实例；factory 调用了 provider，将其定义的内容放在 $get 中返回。factory
                和 service 功能类似，
                只不过 factory 是普通 function，可以返回任何东西（return 的都可以被访问，所以那些私有变量怎么写你懂的）；service 是构造器，可以不返回（绑定到 this
                的都可以被访问）；provider 是加强版 factory，返回一个可配置的 factory。<br>
                7、ng-if 跟 ng-show/hide的区别有哪些？<br>
                &ensp; &ensp; &nabla; ng-if 在后面表达式为 true 的时候才创建这个 dom 节点，ng-show 是初始时就创建了，用 display:block 和 display:none
                来控制显示和不显示。<br>
                &ensp; &ensp; &nabla; ng-if 会（隐式地）产生新作用域，ng-switch 、 ng-include 等会动态创建一块界面的也是如此。<br>
                8、ng-repeat迭代数组的时候，如果数组中有相同值，会有什么问题，如何解决？<br>
                &ensp; &ensp; &nabla; 会提示 Duplicates in a repeater are not allowed. 加 track by $index 可解决。当然，也可以 trace
                by 任何一个普通的值，只要能唯一性标识数组中的每一项即可（建立 dom 和数据之间的关联）。<br>
                9、AngularJS的数据双向绑定是怎么实现的？<br>
                &ensp; &ensp; &nabla; 每个双向绑定的元素都有一个watcher<br>
                &ensp; &ensp; &nabla; 在某些事件发生的时候，调用digest脏数据检测。<br>
                &ensp; &ensp; &nabla; 这些事件有：表单元素内容变化、Ajax请求响应、点击按钮执行的函数等。<br>
                &ensp; &ensp; &nabla; 脏数据检测会检测rootscope下所有被watcher的元素。<br>
                &ensp; &ensp; &nabla; $digest函数就是脏数据监测<br>
                10、angular 的数据绑定采用什么机制？详述原理？<br>
                &ensp; &ensp; &nabla; Angular 在 scope 模型上设置了一个监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往
                $watch 队列里插入一条 $watch
                ，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时， $digest 循环就会触发，遍历所有的 $watch ，最后更新 dom。<br>
                11、Angular Directive中restrict 中分别可以怎样设置？scope中@,=,&有什么区别？<br>
                &ensp; &ensp; &nabla; restrict中可以分别设置:<br>
                &ensp; &ensp; &nabla; A匹配属性<br>
                &ensp; &ensp; &nabla; E匹配标签<br>
                &ensp; &ensp; &nabla; C匹配class<br>
                &ensp; &ensp; &nabla; M 匹配注释<br>
                &ensp; &ensp; &nabla; 在scope中，@,=,&在进行值绑定时分别表示<br>
                &ensp; &ensp; &nabla; @获取一个设置的字符串，它可以自己设置的也可以使用{{yourModel}}进行绑定的;<br>
                &ensp; &ensp; &nabla; = 双向绑定，绑定scope上的一些属性；<br>
                &ensp; &ensp; &nabla; & 用于执行父级scope上的一些表达式，常见我们设置一些需要执行的函数<br>
                12、写controller逻辑的时候 你需要注意什么？<br>
                &ensp; &ensp; &nabla; 简化代码（这个是所有开发人员都要具备的）<br>
                &ensp; &ensp; &nabla; 坚决不能操作dom节点 这个时候可能会问 为什么不能啊<br>
                &ensp; &ensp; &nabla;
                你的回答是：DOM操作只能出现在指令（directive）中。最不应该出现的位置就是服务（service）中。Angular倡导以测试驱动开发，在service或者controller中出现了DOM操作，那么也就意味着的测试是无法通过的。
                当然，这只是一点，重要的是使用Angular的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑，无需关系一堆堆的DOM操作。如果在Angular的代码中还到处充斥着各种DOM操作，那为什么不直接使用jquery去开发呢。<br>
                13、angular和jquery的区别？<br>
                &ensp; &ensp; &nabla; angular是基于数据驱动，所以angular适合做数据操作比较繁琐的项目<br>
                &ensp; &ensp; &nabla; jquery是基于dom驱动，jquery适合做dom操作多的项目<br>
                14、阐述下你对mvc和mvvm的理解<br>
                &ensp; &ensp; &nabla;
                随着代码规模越来越大，切分职责是大势所趋，还有为了后期维护方便，修改一块功能不影响其他功能。还有为了复用，因为很多逻辑是一样的。而MVC只是手段，终极目标是模块化和复用。<br>
                &ensp; &ensp; &nabla; 在angular中MVVM模式主要分为四部分：<br>
                &ensp; &ensp; &ensp; &ensp; &ensp; ①View：它专注于界面的显示和渲染，在angular中则是包含一堆声明式Directive的视图模板。<br>
                &ensp; &ensp; &ensp; &ensp; &ensp;
                ②ViewModel：它是View和Model的粘合体，负责View和Model的交互和协作，它负责给View提供显示的数据，以及提供了View中Command事件操作Model的途径；在angular中$scope对象充当了这个ViewModel的角色；<br>
                &ensp; &ensp; &ensp; &ensp; &ensp;
                ③Model：它是与应用程序的业务逻辑相关的数据的封装载体，它是业务领域的对象，Model并不关心会被如何显示或操作，所以模型也不会包含任何界面显示相关的逻辑。在web页面中，大部分Model都是来自Ajax的服务端返回数据或者是全局的配置对象；而angular中的service则是封装和处理这些与Model相关的业务逻辑的场所，这类的业务服务是可以被多个Controller或者其他service复用的领域服务。<br>
                &ensp; &ensp; &ensp; &ensp; &ensp;
                ④Controller：这并不是MVVM模式的核心元素，但它负责ViewModel对象的初始化，它将组合一个或者多个service来获取业务领域Model放在ViewModel对象上，使得应用界面在启动加载的时候达到一种可用的状态。<br>
            </li>
        </ul>
    </div>

</div>
<script src="px2.js"></script>
</body>
</html>
